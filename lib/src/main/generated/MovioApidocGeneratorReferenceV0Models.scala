/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.1.0-SNAPSHOT
 * apidoc:0.11.21 http://dockerhost:9000/movio/apidoc-generator-reference/0.1.0-SNAPSHOT/test_advanced_scala_models
 */
package movio.apidoc.generator.reference.v0.models {

  case class Address(
    street: String,
    tags: Seq[String]
  ) {

    import Validation._
    validateMaxLength("street", street, 255)
    validateMaxSize("tags", tags, 10)
    validateMinSize("tags", tags, 1)
    validateMaxLengthOfAll("tags", tags, 20)
    validateMinLengthOfAll("tags", tags, 5)

  }

  /**
   * An error message from the API.
   */
  case class Error(
    status: String,
    message: String
  ) {

    import Validation._


  }

  case class Healthcheck(
    status: String = "healthy"
  ) {

    import Validation._


  }

  case class KafkaPerson(
    v0: movio.apidoc.generator.reference.v0.models.Person,
    utcGeneratedTime: _root_.org.joda.time.LocalDateTime = org.joda.time.LocalDateTime.now(org.joda.time.DateTimeZone.UTC)
  ) extends KafkaMessage {

    import Validation._

    def generateKey(tenant: String) = v0.id
  }

  /**
   * This is a person
   */
  case class Person(
    id: String,
    name: String,
    lastActiveTime: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    dob: _root_.scala.Option[_root_.org.joda.time.LocalDate] = None,
    addresses: Seq[movio.apidoc.generator.reference.v0.models.Address],
    gender: movio.apidoc.generator.reference.v0.models.Gender
  ) {

    import Validation._
    validateMaxLength("id", id, 5)
    validateMinLength("id", id, 1)
    validateRegex("id", id, "^[A-Za-z0-9]+$")
    validateMaxLength("name", name, 255)
    validateMinLength("name", name, 1)

  }

  /**
   * Gender of a `Person`
   */
  sealed trait Gender

  object Gender {

    /**
     * male person
     */
    case object Male extends Gender { override def toString = "male" }
    /**
     * female person
     */
    case object Female extends Gender { override def toString = "female" }
    /**
     * other
     */
    case object Other extends Gender { override def toString = "other" }

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Male, Female, Other)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Gender = fromString(value).getOrElse(throw new IllegalArgumentException(s"$value is not valid."))

    def fromString(value: String): _root_.scala.Option[Gender] = byName.get(value.toLowerCase)

  }

  object Validation {

    def validateMaxLength(name: String, value: _root_.scala.Option[String], length: Int): Unit = {
      value foreach { value ⇒
        validateMaxLength(name, value, length)
      }
    }

    def validateMax[T](name: String, value: T, max: T)(implicit n:Numeric[T]): Unit = {
      require(n.lteq(value , max), s"$name must be less than or equal to $max")
    }

    def validateMin[T](name: String, value: T, min: T)(implicit n:Numeric[T]): Unit = {
      require(n.gteq(value , min), s"$name must be greater than or equal to $min")
    }

    def validateMaxSize(name: String, value: Seq[_], size: Int): Unit = {
      require(value.size <= size, s"$name must have less than $size items")
    }

    def validateMinSize(name: String, value: Seq[_], size: Int): Unit = {
      require(value.size >= size, s"$name must have less than $size items")
    }

    def validateMaxLength(name: String, value: String, length: Int): Unit = {
      require(value.codePointCount(0, value.length) <= length, s"$name must be $length characters or less")
    }

    def validateMinLength(name: String, value: String, length: Int): Unit = {
      require(value.codePointCount(0, value.length) >= length, s"$name must be more than $length characters")
    }

    def validateMaxLengthOfAll(name: String, values: _root_.scala.Option[Seq[String]], length: Int): Unit = {
      values foreach { values ⇒
        validateMaxLengthOfAll(name, values, length)
      }
    }

    def validateMaxLengthOfAll(name: String, values: Seq[String], length: Int): Unit = {
      values foreach { value ⇒
        validateMaxLength(name, value, length)
      }
    }

    def validateMinLengthOfAll(name: String, values: _root_.scala.Option[Seq[String]], length: Int): Unit = {
      values foreach { values ⇒
        validateMinLengthOfAll(name, values, length)
      }
    }

    def validateMinLengthOfAll(name: String, values: Seq[String], length: Int): Unit = {
      values foreach { value ⇒
        validateMinLength(name, value, length)
      }
    }

    def validateMaxLengthOfAll[T](name: String, values: Seq[T], max: T)(implicit n: Numeric[T]): Unit = {
      values foreach { value ⇒
        validateMax(name, value, max)
      }
    }

    def validateMinLengthOfAll[T](name: String, values: Seq[T], min: T)(implicit n: Numeric[T]): Unit = {
      values foreach { value ⇒
        validateMin(name, value, min)
      }
    }

    def validateMaxLengthOfAll[T](name: String, values: _root_.scala.Option[Seq[T]], max: T)(implicit n: Numeric[T]): Unit = {
      values foreach { values ⇒
        validateMaxLengthOfAll(name, values, max)
      }
    }

    def validateMinLengthOfAll[T](name: String, values: _root_.scala.Option[Seq[T]], min: T)(implicit n: Numeric[T]): Unit = {
      values foreach { values ⇒
        validateMinLengthOfAll(name, values, min)
      }
    }

    def validateRegex(name: String, value: String, regex: String): Unit = {
      require(regex.r.findFirstIn(value).isDefined, s"$name did not match regex: $regex")
    }

  }


  trait KafkaMessage {

    /**
      A scala statement/code that returns the kafka key to use
      Usually something like `data.exhibitorId`
      */
    def generateKey(tenant: String): String
  }

}