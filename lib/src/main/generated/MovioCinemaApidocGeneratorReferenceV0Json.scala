/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.0.1-SNAPSHOT
 * apidoc:0.11.21 http://dockerhost:9000/movio.cinema/apidoc-generator-reference/0.0.1-SNAPSHOT/jack-testplay_2_x_json_standalone
 */

package movio.cinema.apidoc.generator.reference.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import org.joda.time.format.DateTimeFormat
    import org.joda.time.format.DateTimeFormatterBuilder
    import movio.cinema.apidoc.generator.reference.v0.models.json._

    private[v0] val DateTimeFormatter =
      new DateTimeFormatterBuilder().append(
        org.joda.time.format.ISODateTimeFormat.dateTime.getPrinter,
        Array(
          DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ssZZ").getParser,
          DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSSZZ").getParser
        )
      ).toFormatter

    private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      DateTimeFormatter.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        val str = DateTimeFormatter.print(x)
        JsString(str)
      }
    }

    private[v0] implicit val jsonReadsJodaLocalDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseLocalDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDateTime = new Writes[org.joda.time.LocalDateTime] {
      def writes(x: org.joda.time.LocalDateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    private[v0] implicit val jsonReadsJodaDateTimeZone = __.read[String].map { str =>
      org.joda.time.DateTimeZone.forID(str)
    }

    private[v0] implicit val jsonWritesJodaDateTimeZone = new Writes[org.joda.time.DateTimeZone] {
      def writes(x: org.joda.time.DateTimeZone) = JsString(x.getID)
    }

    object AddressFields {
      val street = "street"
      val tags = "tags"
    }

    implicit def jsonReadsApidocGeneratorReferenceAddress: play.api.libs.json.Reads[Address] = new play.api.libs.json.Reads[Address] {
      def reads(json: play.api.libs.json.JsValue) = {
        try {
          (
            (__ \ AddressFields.street).read[String] and
            (__ \ AddressFields.tags).read[Seq[String]]
          )(Address.apply _).reads(json)
        } catch {
          // Catch Validation Errors
          case ex: IllegalArgumentException => play.api.libs.json.JsError(s"${ex.getMessage}")
        }
      }
    }

    implicit def jsonWritesApidocGeneratorReferenceAddress: play.api.libs.json.Writes[Address] = {
      (
        (__ \ AddressFields.street).write[String] and
        (__ \ AddressFields.tags).write[Seq[String]]
      )(unlift(Address.unapply _))
    }

    object ErrorFields {
      val status = "status"
      val message = "message"
    }

    implicit def jsonReadsApidocGeneratorReferenceError: play.api.libs.json.Reads[Error] = new play.api.libs.json.Reads[Error] {
      def reads(json: play.api.libs.json.JsValue) = {
        try {
          (
            (__ \ ErrorFields.status).read[String] and
            (__ \ ErrorFields.message).read[String]
          )(Error.apply _).reads(json)
        } catch {
          // Catch Validation Errors
          case ex: IllegalArgumentException => play.api.libs.json.JsError(s"${ex.getMessage}")
        }
      }
    }

    implicit def jsonWritesApidocGeneratorReferenceError: play.api.libs.json.Writes[Error] = {
      (
        (__ \ ErrorFields.status).write[String] and
        (__ \ ErrorFields.message).write[String]
      )(unlift(Error.unapply _))
    }

    object HealthcheckFields {
      val status = "status"
    }

    implicit def jsonReadsApidocGeneratorReferenceHealthcheck: play.api.libs.json.Reads[Healthcheck] = new play.api.libs.json.Reads[Healthcheck] {
      def reads(json: play.api.libs.json.JsValue) = {
        try {
          (__ \ HealthcheckFields.status).read[String].map { x => new Healthcheck(status = x) }.reads(json)
        } catch {
          // Catch Validation Errors
          case ex: IllegalArgumentException => play.api.libs.json.JsError(s"${ex.getMessage}")
        }
      }
    }

    implicit def jsonWritesApidocGeneratorReferenceHealthcheck: play.api.libs.json.Writes[Healthcheck] = new play.api.libs.json.Writes[Healthcheck] {
      def writes(x: Healthcheck) = play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.Json.toJson(x.status)
      )
    }

    object KafkaPersonFields {
      val v0 = "v0"
      val utc_generated_time = "utc_generated_time"
    }

    implicit def jsonReadsApidocGeneratorReferenceKafkaPerson: play.api.libs.json.Reads[KafkaPerson] = new play.api.libs.json.Reads[KafkaPerson] {
      def reads(json: play.api.libs.json.JsValue) = {
        try {
          (
            (__ \ KafkaPersonFields.v0).read[movio.cinema.apidoc.generator.reference.v0.models.Person] and
            (__ \ KafkaPersonFields.utc_generated_time).read[_root_.org.joda.time.LocalDateTime]
          )(KafkaPerson.apply _).reads(json)
        } catch {
          // Catch Validation Errors
          case ex: IllegalArgumentException => play.api.libs.json.JsError(s"${ex.getMessage}")
        }
      }
    }

    implicit def jsonWritesApidocGeneratorReferenceKafkaPerson: play.api.libs.json.Writes[KafkaPerson] = {
      (
        (__ \ KafkaPersonFields.v0).write[movio.cinema.apidoc.generator.reference.v0.models.Person] and
        (__ \ KafkaPersonFields.utc_generated_time).write[_root_.org.joda.time.LocalDateTime]
      )(unlift(KafkaPerson.unapply _))
    }

    object PersonFields {
      val id = "id"
      val name = "name"
      val lastActiveTime = "lastActiveTime"
      val dob = "dob"
      val addresses = "addresses"
    }

    implicit def jsonReadsApidocGeneratorReferencePerson: play.api.libs.json.Reads[Person] = new play.api.libs.json.Reads[Person] {
      def reads(json: play.api.libs.json.JsValue) = {
        try {
          (
            (__ \ PersonFields.id).read[String] and
            (__ \ PersonFields.name).read[String] and
            (__ \ PersonFields.lastActiveTime).readNullable[_root_.org.joda.time.DateTime] and
            (__ \ PersonFields.dob).readNullable[_root_.org.joda.time.LocalDate] and
            (__ \ PersonFields.addresses).read[Seq[movio.cinema.apidoc.generator.reference.v0.models.Address]]
          )(Person.apply _).reads(json)
        } catch {
          // Catch Validation Errors
          case ex: IllegalArgumentException => play.api.libs.json.JsError(s"${ex.getMessage}")
        }
      }
    }

    implicit def jsonWritesApidocGeneratorReferencePerson: play.api.libs.json.Writes[Person] = {
      (
        (__ \ PersonFields.id).write[String] and
        (__ \ PersonFields.name).write[String] and
        (__ \ PersonFields.lastActiveTime).writeNullable[_root_.org.joda.time.DateTime] and
        (__ \ PersonFields.dob).writeNullable[_root_.org.joda.time.LocalDate] and
        (__ \ PersonFields.addresses).write[Seq[movio.cinema.apidoc.generator.reference.v0.models.Address]]
      )(unlift(Person.unapply _))
    }
  }
}
