 /**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.1.0-SNAPSHOT
 * apidoc:0.11.6 http://localhost:9000/movio/apidoc-generator-reference/0.1.0-SNAPSHOT/kafka_0_8_tests
 */

package movio.apidoc.generator.reference.v0.kafka

import scala.util.Try
import scala.util.Success

import org.joda.time.LocalDateTime
import org.mockito.Matchers.any
import org.mockito.Matchers.{ eq â‡’ is }

import com.typesafe.config.ConfigFactory

import movio.testtools.MovioSpec
import movio.testtools.kafka.{ KafkaTestKit, KafkaTestKitUtils }


class KafkaPersonTests extends MovioSpec with KafkaTestKit {
  import movio.apidoc.generator.reference.v0.models._

  val kafkaServer = createKafkaServer()
  kafkaServer.startup()

  override def afterAll() = {
    kafkaServer.shutdown()
    zkServer.stop()
  }

  describe("KafkaPerson Producer and Consumer") {
    it("should timeout with no messages") {
      new Fixture {
        awaitCondition("Message should get processed") {
          def processor(messages: Map[String, Seq[KafkaPerson]]): Try[Map[String, Seq[KafkaPerson]]] =  Success(messages)
          consumer.processBatchThenCommit(processor) shouldBe Success(Map.empty)
        }

        consumer.shutdown
      }
    }

    it("should send and receive a message") {
      new Fixture {
        // Produce test message
        producer.sendWrapped(entity1, tenant)

        // And consume it
        awaitCondition("Message should get processed") {
          def processor(messages: Map[String, Seq[KafkaPerson]]): Try[Map[String, Seq[KafkaPerson]]] = {
            println(messages)
            println("do some side effecting stuff here")
            Success(messages)
          }
          consumer.processBatchThenCommit(processor).get(tenant) shouldBe Seq(entity1)
        }

        consumer.shutdown
      }
    }

    it("should send and receive a batch of messages") {
      new Fixture {
        val entities = Seq(entity1, entity2)

        // Produce test message
        producer.sendWrapped(entities, tenant)

        // And consume it
        awaitCondition("Message should get processed") {
          def processor(messages: Map[String, Seq[KafkaPerson]]): Try[Map[String, Seq[KafkaPerson]]] =  {
            println(messages)
            println("do some side effecting stuff here")
            Success(messages)
          }
          // Use distinct because there are items in the queue from other tests
          consumer.processBatchThenCommit(processor, 100).get(tenant) shouldBe entities
        }

        consumer.shutdown
      }
    }
  }

  trait Fixture {

    val brokerConnectionString = kafkaServer.config.hostName + ":" + kafkaServer.config.port
    val tenant = KafkaTestKitUtils.tempTopic()

    val testConfig = ConfigFactory.parseString(s"""
      |configuration {
      |  log-on-startup = false
      |}
      |
      |movio.apidoc.generator.reference.kafka {
      |  producer {
      |    broker-connection-string : "$brokerConnectionString"
      |  }
      |}
      |
      |movio.apidoc.generator.reference.kafka {
      |  consumer {
      |    offset-storage-type = "kafka"
      |    offset-storage-dual-commit = false
      |    timeout.ms = "100"
      |    zookeeper.connection = "${zkServer.getConnectString}"
      |  }
      |}
      |""".stripMargin)
      .withFallback(ConfigFactory.load())

    val producer = new KafkaPersonProducer(testConfig)
    val consumer = new KafkaPersonConsumer(testConfig, new java.util.Random().nextInt.toString)
  }

  val entity1 = 
    KafkaPerson (
      v0 = 
        Person (
          id = "id1",
          name = "name1",
          dob = None,
          addresses = List.empty
        ),
      utcGeneratedTime = new org.joda.time.Date()
    )
  val entity2 = 
    KafkaPerson (
      v0 = 
        Person (
          id = "id2",
          name = "name2",
          dob = None,
          addresses = List.empty
        ),
      utcGeneratedTime = new org.joda.time.Date()
    )
}
